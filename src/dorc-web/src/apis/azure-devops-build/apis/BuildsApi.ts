// tslint:disable
/**
 * Build
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.1-preview
 * Contact: nugetvss@microsoft.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import type { HttpHeaders, HttpQuery, OperationOpts } from '../runtime';
import { BaseAPI, encodeURI, throwIfNullOrUndefined } from '../runtime';
import type {
  Build,
  BuildLog,
  Change,
  ResourceRef,
  RetentionLease
} from '../models';

export interface BuildsDeleteRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
}

export interface BuildsGetRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
  propertyFilters?: string;
}

export interface BuildsGetBuildChangesRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
  continuationToken?: string;
  $top?: number;
  includeSourceChange?: boolean;
}

export interface BuildsGetBuildLogRequest {
  organization: string;
  project: string;
  buildId: number;
  logId: number;
  apiVersion: string;
  startLine?: number;
  endLine?: number;
}

export interface BuildsGetBuildLogsRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
}

export interface BuildsGetBuildWorkItemsRefsRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
  $top?: number;
}

export interface BuildsGetBuildWorkItemsRefsFromCommitsRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
  body: Array<string>;
  $top?: number;
}

export interface BuildsGetChangesBetweenBuildsRequest {
  organization: string;
  project: string;
  apiVersion: string;
  fromBuildId?: number;
  toBuildId?: number;
  $top?: number;
}

export interface BuildsGetRetentionLeasesForBuildRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
}

export interface BuildsGetWorkItemsBetweenBuildsRequest {
  organization: string;
  project: string;
  fromBuildId: number;
  toBuildId: number;
  apiVersion: string;
  $top?: number;
}

export interface BuildsListRequest {
  organization: string;
  project: string;
  apiVersion: string;
  definitions?: string;
  queues?: string;
  buildNumber?: string;
  minTime?: string;
  maxTime?: string;
  requestedFor?: string;
  reasonFilter?: BuildsListReasonFilterEnum;
  statusFilter?: BuildsListStatusFilterEnum;
  resultFilter?: BuildsListResultFilterEnum;
  tagFilters?: string;
  properties?: string;
  $top?: number;
  continuationToken?: string;
  maxBuildsPerDefinition?: number;
  deletedFilter?: BuildsListDeletedFilterEnum;
  queryOrder?: BuildsListQueryOrderEnum;
  branchName?: string;
  buildIds?: string;
  repositoryId?: string;
  repositoryType?: string;
}

export interface BuildsQueueRequest {
  organization: string;
  project: string;
  apiVersion: string;
  body: Build;
  ignoreWarnings?: boolean;
  checkInTicket?: string;
  sourceBuildId?: number;
  definitionId?: number;
}

export interface BuildsUpdateBuildRequest {
  organization: string;
  project: string;
  buildId: number;
  apiVersion: string;
  body: Build;
  retry?: boolean;
}

export interface BuildsUpdateBuildsRequest {
  organization: string;
  project: string;
  apiVersion: string;
  body: Array<Build>;
}

/**
 * no description
 */
export class BuildsApi extends BaseAPI {
  /**
   * Deletes a build.
   */
  buildsDelete({
    organization,
    project,
    buildId,
    apiVersion
  }: BuildsDeleteRequest): Observable<void>;
  buildsDelete(
    { organization, project, buildId, apiVersion }: BuildsDeleteRequest,
    opts?: OperationOpts
  ): Observable<void | AjaxResponse<void>>;
  buildsDelete(
    { organization, project, buildId, apiVersion }: BuildsDeleteRequest,
    opts?: OperationOpts
  ): Observable<void | AjaxResponse<void>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsDelete');
    throwIfNullOrUndefined(project, 'project', 'buildsDelete');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsDelete');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsDelete');

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', [
                    'vso.build_execute'
                  ])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    return this.request<void>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'DELETE',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets a build
   */
  buildsGet({
    organization,
    project,
    buildId,
    apiVersion,
    propertyFilters
  }: BuildsGetRequest): Observable<Build>;
  buildsGet(
    {
      organization,
      project,
      buildId,
      apiVersion,
      propertyFilters
    }: BuildsGetRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Build>>;
  buildsGet(
    {
      organization,
      project,
      buildId,
      apiVersion,
      propertyFilters
    }: BuildsGetRequest,
    opts?: OperationOpts
  ): Observable<Build | AjaxResponse<Build>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsGet');
    throwIfNullOrUndefined(project, 'project', 'buildsGet');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsGet');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsGet');

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (propertyFilters != null) {
      query['propertyFilters'] = propertyFilters;
    }

    return this.request<Build>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets the changes associated with a build
   */
  buildsGetBuildChanges({
    organization,
    project,
    buildId,
    apiVersion,
    continuationToken,
    $top,
    includeSourceChange
  }: BuildsGetBuildChangesRequest): Observable<Array<Change>>;
  buildsGetBuildChanges(
    {
      organization,
      project,
      buildId,
      apiVersion,
      continuationToken,
      $top,
      includeSourceChange
    }: BuildsGetBuildChangesRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<Change>>>;
  buildsGetBuildChanges(
    {
      organization,
      project,
      buildId,
      apiVersion,
      continuationToken,
      $top,
      includeSourceChange
    }: BuildsGetBuildChangesRequest,
    opts?: OperationOpts
  ): Observable<Array<Change> | AjaxResponse<Array<Change>>> {
    throwIfNullOrUndefined(
      organization,
      'organization',
      'buildsGetBuildChanges'
    );
    throwIfNullOrUndefined(project, 'project', 'buildsGetBuildChanges');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsGetBuildChanges');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsGetBuildChanges');

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (continuationToken != null) {
      query['continuationToken'] = continuationToken;
    }
    if ($top != null) {
      query['$top'] = $top;
    }
    if (includeSourceChange != null) {
      query['includeSourceChange'] = includeSourceChange;
    }

    return this.request<Array<Change>>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}/changes'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets an individual log file for a build.
   */
  buildsGetBuildLog({
    organization,
    project,
    buildId,
    logId,
    apiVersion,
    startLine,
    endLine
  }: BuildsGetBuildLogRequest): Observable<string>;
  buildsGetBuildLog(
    {
      organization,
      project,
      buildId,
      logId,
      apiVersion,
      startLine,
      endLine
    }: BuildsGetBuildLogRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<string>>;
  buildsGetBuildLog(
    {
      organization,
      project,
      buildId,
      logId,
      apiVersion,
      startLine,
      endLine
    }: BuildsGetBuildLogRequest,
    opts?: OperationOpts
  ): Observable<string | AjaxResponse<string>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsGetBuildLog');
    throwIfNullOrUndefined(project, 'project', 'buildsGetBuildLog');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsGetBuildLog');
    throwIfNullOrUndefined(logId, 'logId', 'buildsGetBuildLog');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsGetBuildLog');

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (startLine != null) {
      query['startLine'] = startLine;
    }
    if (endLine != null) {
      query['endLine'] = endLine;
    }

    return this.request<string>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}/logs/{logId}'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId))
          .replace('{logId}', encodeURI(logId)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets the logs for a build.
   */
  buildsGetBuildLogs({
    organization,
    project,
    buildId,
    apiVersion
  }: BuildsGetBuildLogsRequest): Observable<Array<BuildLog>>;
  buildsGetBuildLogs(
    { organization, project, buildId, apiVersion }: BuildsGetBuildLogsRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<BuildLog>>>;
  buildsGetBuildLogs(
    { organization, project, buildId, apiVersion }: BuildsGetBuildLogsRequest,
    opts?: OperationOpts
  ): Observable<Array<BuildLog> | AjaxResponse<Array<BuildLog>>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsGetBuildLogs');
    throwIfNullOrUndefined(project, 'project', 'buildsGetBuildLogs');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsGetBuildLogs');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsGetBuildLogs');

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    return this.request<Array<BuildLog>>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}/logs'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets the work items associated with a build. Only work items in the same project are returned.
   */
  buildsGetBuildWorkItemsRefs({
    organization,
    project,
    buildId,
    apiVersion,
    $top
  }: BuildsGetBuildWorkItemsRefsRequest): Observable<Array<ResourceRef>>;
  buildsGetBuildWorkItemsRefs(
    {
      organization,
      project,
      buildId,
      apiVersion,
      $top
    }: BuildsGetBuildWorkItemsRefsRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<ResourceRef>>>;
  buildsGetBuildWorkItemsRefs(
    {
      organization,
      project,
      buildId,
      apiVersion,
      $top
    }: BuildsGetBuildWorkItemsRefsRequest,
    opts?: OperationOpts
  ): Observable<Array<ResourceRef> | AjaxResponse<Array<ResourceRef>>> {
    throwIfNullOrUndefined(
      organization,
      'organization',
      'buildsGetBuildWorkItemsRefs'
    );
    throwIfNullOrUndefined(project, 'project', 'buildsGetBuildWorkItemsRefs');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsGetBuildWorkItemsRefs');
    throwIfNullOrUndefined(
      apiVersion,
      'apiVersion',
      'buildsGetBuildWorkItemsRefs'
    );

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if ($top != null) {
      query['$top'] = $top;
    }

    return this.request<Array<ResourceRef>>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}/workitems'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets the work items associated with a build, filtered to specific commits.
   */
  buildsGetBuildWorkItemsRefsFromCommits({
    organization,
    project,
    buildId,
    apiVersion,
    body,
    $top
  }: BuildsGetBuildWorkItemsRefsFromCommitsRequest): Observable<
    Array<ResourceRef>
  >;
  buildsGetBuildWorkItemsRefsFromCommits(
    {
      organization,
      project,
      buildId,
      apiVersion,
      body,
      $top
    }: BuildsGetBuildWorkItemsRefsFromCommitsRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<ResourceRef>>>;
  buildsGetBuildWorkItemsRefsFromCommits(
    {
      organization,
      project,
      buildId,
      apiVersion,
      body,
      $top
    }: BuildsGetBuildWorkItemsRefsFromCommitsRequest,
    opts?: OperationOpts
  ): Observable<Array<ResourceRef> | AjaxResponse<Array<ResourceRef>>> {
    throwIfNullOrUndefined(
      organization,
      'organization',
      'buildsGetBuildWorkItemsRefsFromCommits'
    );
    throwIfNullOrUndefined(
      project,
      'project',
      'buildsGetBuildWorkItemsRefsFromCommits'
    );
    throwIfNullOrUndefined(
      buildId,
      'buildId',
      'buildsGetBuildWorkItemsRefsFromCommits'
    );
    throwIfNullOrUndefined(
      apiVersion,
      'apiVersion',
      'buildsGetBuildWorkItemsRefsFromCommits'
    );
    throwIfNullOrUndefined(
      body,
      'body',
      'buildsGetBuildWorkItemsRefsFromCommits'
    );

    const headers: HttpHeaders = {
      'Content-Type': 'application/json',
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', [
                    'vso.build_execute'
                  ])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if ($top != null) {
      query['$top'] = $top;
    }

    return this.request<Array<ResourceRef>>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}/workitems'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'POST',
        headers,
        query,
        body: body
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets the changes made to the repository between two given builds.
   */
  buildsGetChangesBetweenBuilds({
    organization,
    project,
    apiVersion,
    fromBuildId,
    toBuildId,
    $top
  }: BuildsGetChangesBetweenBuildsRequest): Observable<Array<Change>>;
  buildsGetChangesBetweenBuilds(
    {
      organization,
      project,
      apiVersion,
      fromBuildId,
      toBuildId,
      $top
    }: BuildsGetChangesBetweenBuildsRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<Change>>>;
  buildsGetChangesBetweenBuilds(
    {
      organization,
      project,
      apiVersion,
      fromBuildId,
      toBuildId,
      $top
    }: BuildsGetChangesBetweenBuildsRequest,
    opts?: OperationOpts
  ): Observable<Array<Change> | AjaxResponse<Array<Change>>> {
    throwIfNullOrUndefined(
      organization,
      'organization',
      'buildsGetChangesBetweenBuilds'
    );
    throwIfNullOrUndefined(project, 'project', 'buildsGetChangesBetweenBuilds');
    throwIfNullOrUndefined(
      apiVersion,
      'apiVersion',
      'buildsGetChangesBetweenBuilds'
    );

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (fromBuildId != null) {
      query['fromBuildId'] = fromBuildId;
    }
    if (toBuildId != null) {
      query['toBuildId'] = toBuildId;
    }
    if ($top != null) {
      query['$top'] = $top;
    }

    return this.request<Array<Change>>(
      {
        url: '/{organization}/{project}/_apis/build/changes'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets all retention leases that apply to a specific build.
   */
  buildsGetRetentionLeasesForBuild({
    organization,
    project,
    buildId,
    apiVersion
  }: BuildsGetRetentionLeasesForBuildRequest): Observable<
    Array<RetentionLease>
  >;
  buildsGetRetentionLeasesForBuild(
    {
      organization,
      project,
      buildId,
      apiVersion
    }: BuildsGetRetentionLeasesForBuildRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<RetentionLease>>>;
  buildsGetRetentionLeasesForBuild(
    {
      organization,
      project,
      buildId,
      apiVersion
    }: BuildsGetRetentionLeasesForBuildRequest,
    opts?: OperationOpts
  ): Observable<Array<RetentionLease> | AjaxResponse<Array<RetentionLease>>> {
    throwIfNullOrUndefined(
      organization,
      'organization',
      'buildsGetRetentionLeasesForBuild'
    );
    throwIfNullOrUndefined(
      project,
      'project',
      'buildsGetRetentionLeasesForBuild'
    );
    throwIfNullOrUndefined(
      buildId,
      'buildId',
      'buildsGetRetentionLeasesForBuild'
    );
    throwIfNullOrUndefined(
      apiVersion,
      'apiVersion',
      'buildsGetRetentionLeasesForBuild'
    );

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    return this.request<Array<RetentionLease>>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}/leases'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets all the work items between two builds.
   */
  buildsGetWorkItemsBetweenBuilds({
    organization,
    project,
    fromBuildId,
    toBuildId,
    apiVersion,
    $top
  }: BuildsGetWorkItemsBetweenBuildsRequest): Observable<Array<ResourceRef>>;
  buildsGetWorkItemsBetweenBuilds(
    {
      organization,
      project,
      fromBuildId,
      toBuildId,
      apiVersion,
      $top
    }: BuildsGetWorkItemsBetweenBuildsRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<ResourceRef>>>;
  buildsGetWorkItemsBetweenBuilds(
    {
      organization,
      project,
      fromBuildId,
      toBuildId,
      apiVersion,
      $top
    }: BuildsGetWorkItemsBetweenBuildsRequest,
    opts?: OperationOpts
  ): Observable<Array<ResourceRef> | AjaxResponse<Array<ResourceRef>>> {
    throwIfNullOrUndefined(
      organization,
      'organization',
      'buildsGetWorkItemsBetweenBuilds'
    );
    throwIfNullOrUndefined(
      project,
      'project',
      'buildsGetWorkItemsBetweenBuilds'
    );
    throwIfNullOrUndefined(
      fromBuildId,
      'fromBuildId',
      'buildsGetWorkItemsBetweenBuilds'
    );
    throwIfNullOrUndefined(
      toBuildId,
      'toBuildId',
      'buildsGetWorkItemsBetweenBuilds'
    );
    throwIfNullOrUndefined(
      apiVersion,
      'apiVersion',
      'buildsGetWorkItemsBetweenBuilds'
    );

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', [
                    'vso.work',
                    'vso.build'
                  ])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      fromBuildId: fromBuildId,
      toBuildId: toBuildId,
      'api-version': apiVersion
    };

    if ($top != null) {
      query['$top'] = $top;
    }

    return this.request<Array<ResourceRef>>(
      {
        url: '/{organization}/{project}/_apis/build/workitems'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Gets a list of builds.
   */
  buildsList({
    organization,
    project,
    apiVersion,
    definitions,
    queues,
    buildNumber,
    minTime,
    maxTime,
    requestedFor,
    reasonFilter,
    statusFilter,
    resultFilter,
    tagFilters,
    properties,
    $top,
    continuationToken,
    maxBuildsPerDefinition,
    deletedFilter,
    queryOrder,
    branchName,
    buildIds,
    repositoryId,
    repositoryType
  }: BuildsListRequest): Observable<Array<Build>>;
  buildsList(
    {
      organization,
      project,
      apiVersion,
      definitions,
      queues,
      buildNumber,
      minTime,
      maxTime,
      requestedFor,
      reasonFilter,
      statusFilter,
      resultFilter,
      tagFilters,
      properties,
      $top,
      continuationToken,
      maxBuildsPerDefinition,
      deletedFilter,
      queryOrder,
      branchName,
      buildIds,
      repositoryId,
      repositoryType
    }: BuildsListRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<Build>>>;
  buildsList(
    {
      organization,
      project,
      apiVersion,
      definitions,
      queues,
      buildNumber,
      minTime,
      maxTime,
      requestedFor,
      reasonFilter,
      statusFilter,
      resultFilter,
      tagFilters,
      properties,
      $top,
      continuationToken,
      maxBuildsPerDefinition,
      deletedFilter,
      queryOrder,
      branchName,
      buildIds,
      repositoryId,
      repositoryType
    }: BuildsListRequest,
    opts?: OperationOpts
  ): Observable<Array<Build> | AjaxResponse<Array<Build>>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsList');
    throwIfNullOrUndefined(project, 'project', 'buildsList');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsList');

    const headers: HttpHeaders = {
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', ['vso.build'])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (definitions != null) {
      query['definitions'] = definitions;
    }
    if (queues != null) {
      query['queues'] = queues;
    }
    if (buildNumber != null) {
      query['buildNumber'] = buildNumber;
    }
    if (minTime != null) {
      query['minTime'] = (minTime as any).toISOString();
    }
    if (maxTime != null) {
      query['maxTime'] = (maxTime as any).toISOString();
    }
    if (requestedFor != null) {
      query['requestedFor'] = requestedFor;
    }
    if (reasonFilter != null) {
      query['reasonFilter'] = reasonFilter;
    }
    if (statusFilter != null) {
      query['statusFilter'] = statusFilter;
    }
    if (resultFilter != null) {
      query['resultFilter'] = resultFilter;
    }
    if (tagFilters != null) {
      query['tagFilters'] = tagFilters;
    }
    if (properties != null) {
      query['properties'] = properties;
    }
    if ($top != null) {
      query['$top'] = $top;
    }
    if (continuationToken != null) {
      query['continuationToken'] = continuationToken;
    }
    if (maxBuildsPerDefinition != null) {
      query['maxBuildsPerDefinition'] = maxBuildsPerDefinition;
    }
    if (deletedFilter != null) {
      query['deletedFilter'] = deletedFilter;
    }
    if (queryOrder != null) {
      query['queryOrder'] = queryOrder;
    }
    if (branchName != null) {
      query['branchName'] = branchName;
    }
    if (buildIds != null) {
      query['buildIds'] = buildIds;
    }
    if (repositoryId != null) {
      query['repositoryId'] = repositoryId;
    }
    if (repositoryType != null) {
      query['repositoryType'] = repositoryType;
    }

    return this.request<Array<Build>>(
      {
        url: '/{organization}/{project}/_apis/build/builds'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project)),
        method: 'GET',
        headers,
        query
      },
      opts?.responseOpts
    );
  }

  /**
   * Queues a build
   */
  buildsQueue({
    organization,
    project,
    apiVersion,
    body,
    ignoreWarnings,
    checkInTicket,
    sourceBuildId,
    definitionId
  }: BuildsQueueRequest): Observable<Build>;
  buildsQueue(
    {
      organization,
      project,
      apiVersion,
      body,
      ignoreWarnings,
      checkInTicket,
      sourceBuildId,
      definitionId
    }: BuildsQueueRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Build>>;
  buildsQueue(
    {
      organization,
      project,
      apiVersion,
      body,
      ignoreWarnings,
      checkInTicket,
      sourceBuildId,
      definitionId
    }: BuildsQueueRequest,
    opts?: OperationOpts
  ): Observable<Build | AjaxResponse<Build>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsQueue');
    throwIfNullOrUndefined(project, 'project', 'buildsQueue');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsQueue');
    throwIfNullOrUndefined(body, 'body', 'buildsQueue');

    const headers: HttpHeaders = {
      'Content-Type': 'application/json',
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', [
                    'vso.build_execute'
                  ])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (ignoreWarnings != null) {
      query['ignoreWarnings'] = ignoreWarnings;
    }
    if (checkInTicket != null) {
      query['checkInTicket'] = checkInTicket;
    }
    if (sourceBuildId != null) {
      query['sourceBuildId'] = sourceBuildId;
    }
    if (definitionId != null) {
      query['definitionId'] = definitionId;
    }

    return this.request<Build>(
      {
        url: '/{organization}/{project}/_apis/build/builds'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project)),
        method: 'POST',
        headers,
        query,
        body: body
      },
      opts?.responseOpts
    );
  }

  /**
   * Updates a build.
   */
  buildsUpdateBuild({
    organization,
    project,
    buildId,
    apiVersion,
    body,
    retry
  }: BuildsUpdateBuildRequest): Observable<Build>;
  buildsUpdateBuild(
    {
      organization,
      project,
      buildId,
      apiVersion,
      body,
      retry
    }: BuildsUpdateBuildRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Build>>;
  buildsUpdateBuild(
    {
      organization,
      project,
      buildId,
      apiVersion,
      body,
      retry
    }: BuildsUpdateBuildRequest,
    opts?: OperationOpts
  ): Observable<Build | AjaxResponse<Build>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsUpdateBuild');
    throwIfNullOrUndefined(project, 'project', 'buildsUpdateBuild');
    throwIfNullOrUndefined(buildId, 'buildId', 'buildsUpdateBuild');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsUpdateBuild');
    throwIfNullOrUndefined(body, 'body', 'buildsUpdateBuild');

    const headers: HttpHeaders = {
      'Content-Type': 'application/json',
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', [
                    'vso.build_execute'
                  ])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    if (retry != null) {
      query['retry'] = retry;
    }

    return this.request<Build>(
      {
        url: '/{organization}/{project}/_apis/build/builds/{buildId}'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project))
          .replace('{buildId}', encodeURI(buildId)),
        method: 'PATCH',
        headers,
        query,
        body: body
      },
      opts?.responseOpts
    );
  }

  /**
   * Updates multiple builds.
   */
  buildsUpdateBuilds({
    organization,
    project,
    apiVersion,
    body
  }: BuildsUpdateBuildsRequest): Observable<Array<Build>>;
  buildsUpdateBuilds(
    { organization, project, apiVersion, body }: BuildsUpdateBuildsRequest,
    opts?: OperationOpts
  ): Observable<AjaxResponse<Array<Build>>>;
  buildsUpdateBuilds(
    { organization, project, apiVersion, body }: BuildsUpdateBuildsRequest,
    opts?: OperationOpts
  ): Observable<Array<Build> | AjaxResponse<Array<Build>>> {
    throwIfNullOrUndefined(organization, 'organization', 'buildsUpdateBuilds');
    throwIfNullOrUndefined(project, 'project', 'buildsUpdateBuilds');
    throwIfNullOrUndefined(apiVersion, 'apiVersion', 'buildsUpdateBuilds');
    throwIfNullOrUndefined(body, 'body', 'buildsUpdateBuilds');

    const headers: HttpHeaders = {
      'Content-Type': 'application/json',
      // oauth required
      ...(this.configuration.accessToken != null
        ? {
            Authorization:
              typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken('oauth2', [
                    'vso.build_execute'
                  ])
                : this.configuration.accessToken
          }
        : undefined)
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      'api-version': apiVersion
    };

    return this.request<Array<Build>>(
      {
        url: '/{organization}/{project}/_apis/build/builds'
          .replace('{organization}', encodeURI(organization))
          .replace('{project}', encodeURI(project)),
        method: 'PATCH',
        headers,
        query,
        body: body
      },
      opts?.responseOpts
    );
  }
}

/**
 * @export
 * @enum {string}
 */
export enum BuildsListReasonFilterEnum {
  None = 'none',
  Manual = 'manual',
  IndividualCi = 'individualCI',
  BatchedCi = 'batchedCI',
  Schedule = 'schedule',
  ScheduleForced = 'scheduleForced',
  UserCreated = 'userCreated',
  ValidateShelveset = 'validateShelveset',
  CheckInShelveset = 'checkInShelveset',
  PullRequest = 'pullRequest',
  BuildCompletion = 'buildCompletion',
  ResourceTrigger = 'resourceTrigger',
  Triggered = 'triggered',
  All = 'all'
}
/**
 * @export
 * @enum {string}
 */
export enum BuildsListStatusFilterEnum {
  None = 'none',
  InProgress = 'inProgress',
  Completed = 'completed',
  Cancelling = 'cancelling',
  Postponed = 'postponed',
  NotStarted = 'notStarted',
  All = 'all'
}
/**
 * @export
 * @enum {string}
 */
export enum BuildsListResultFilterEnum {
  None = 'none',
  Succeeded = 'succeeded',
  PartiallySucceeded = 'partiallySucceeded',
  Failed = 'failed',
  Canceled = 'canceled'
}
/**
 * @export
 * @enum {string}
 */
export enum BuildsListDeletedFilterEnum {
  ExcludeDeleted = 'excludeDeleted',
  IncludeDeleted = 'includeDeleted',
  OnlyDeleted = 'onlyDeleted'
}
/**
 * @export
 * @enum {string}
 */
export enum BuildsListQueryOrderEnum {
  FinishTimeAscending = 'finishTimeAscending',
  FinishTimeDescending = 'finishTimeDescending',
  QueueTimeDescending = 'queueTimeDescending',
  QueueTimeAscending = 'queueTimeAscending',
  StartTimeDescending = 'startTimeDescending',
  StartTimeAscending = 'startTimeAscending'
}
